"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const xpring_common_js_1 = require("xpring-common-js");
const big_integer_1 = __importDefault(require("big-integer"));
const raw_transaction_status_1 = __importDefault(require("../raw-transaction-status"));
const legacy_grpc_network_client_1 = __importDefault(require("./legacy-grpc-network-client"));
const legacy_grpc_network_client_web_1 = __importDefault(require("./legacy-grpc-network-client.web"));
const transaction_status_1 = __importDefault(require("../transaction-status"));
const utils_1 = __importDefault(require("../utils"));
/**
 * Error messages from XpringClient.
 */
class LegacyXpringClientErrorMessages {
}
exports.LegacyXpringClientErrorMessages = LegacyXpringClientErrorMessages;
LegacyXpringClientErrorMessages.malformedResponse = 'Malformed Response.';
LegacyXpringClientErrorMessages.signingFailure = 'Unable to sign the transaction';
LegacyXpringClientErrorMessages.xAddressRequired = 'Please use the X-Address format. See: https://xrpaddress.info/.';
/** A margin to pad the current ledger sequence with when submitting transactions. */
const ledgerSequenceMargin = 10;
/**
 * DefaultXpringClient is a client which interacts with the Xpring platform.
 */
class LegacyDefaultXpringClient {
    /**
     * Create a new DefaultXpringClient with a custom network client implementation.
     *
     * In general, clients should prefer to call `xpringClientWithEndpoint`. This constructor is provided to improve testability of this class.
     *
     * @param networkClient A network client which will manage remote RPCs to Rippled.
     */
    constructor(networkClient) {
        this.networkClient = networkClient;
    }
    /**
     * Create a new DefaultXpringClient.
     *
     * The DefaultXpringClient will use gRPC to communicate with the given endpoint.
     *
     * @param grpcURL The URL of the gRPC instance to connect to.
     * @param forceWeb If `true`, then we will use the gRPC-Web client even when on Node. Defaults to false. This is mainly for testing and in the future will be removed when we have browser testing.
     */
    static defaultXpringClientWithEndpoint(grpcURL, forceWeb = false) {
        return utils_1.default() && !forceWeb
            ? new LegacyDefaultXpringClient(new legacy_grpc_network_client_1.default(grpcURL))
            : new LegacyDefaultXpringClient(new legacy_grpc_network_client_web_1.default(grpcURL));
    }
    /**
     * Retrieve the balance for the given address.
     *
     * @param address The X-Address to retrieve a balance for.
     * @returns A `BigInteger` representing the number of drops of XRP in the account.
     */
    async getBalance(address) {
        if (!xpring_common_js_1.Utils.isValidXAddress(address)) {
            return Promise.reject(new Error(LegacyXpringClientErrorMessages.xAddressRequired));
        }
        return this.getAccountInfo(address).then(async (accountInfo) => {
            const balance = accountInfo.getBalance();
            if (balance === undefined) {
                return Promise.reject(new Error(LegacyXpringClientErrorMessages.malformedResponse));
            }
            return big_integer_1.default(balance.getDrops());
        });
    }
    /**
     * Retrieve the transaction status for a given transaction hash.
     *
     * @param transactionHash The hash of the transaction.
     * @returns The status of the given transaction.
     */
    async getTransactionStatus(transactionHash) {
        const transactionStatus = await this.getRawTransactionStatus(transactionHash);
        // Return pending if the transaction is not validated.
        if (!transactionStatus.isValidated) {
            return transaction_status_1.default.Pending;
        }
        return transactionStatus.transactionStatusCode.startsWith('tes')
            ? transaction_status_1.default.Succeeded
            : transaction_status_1.default.Failed;
    }
    /**
     * Send the given amount of XRP from the source wallet to the destination address.
     *
     * @param drops A `BigInteger`, number or numeric string representing the number of drops to send.
     * @param destination A destination address to send the drops to.
     * @param sender The wallet that XRP will be sent from and which will sign the request.
     * @returns A promise which resolves to a string representing the hash of the submitted transaction.
     */
    async send(amount, destination, sender) {
        if (!xpring_common_js_1.Utils.isValidXAddress(destination)) {
            return Promise.reject(new Error(LegacyXpringClientErrorMessages.xAddressRequired));
        }
        const normalizedAmount = big_integer_1.default(amount.toString());
        return this.getFee().then(async (fee) => {
            return this.getAccountInfo(sender.getAddress()).then(async (accountInfo) => {
                return this.getLastValidatedLedgerSequence().then(async (ledgerSequence) => {
                    if (accountInfo.getSequence() === undefined) {
                        return Promise.reject(new Error(LegacyXpringClientErrorMessages.malformedResponse));
                    }
                    const xrpAmount = this.networkClient.XRPAmount();
                    xrpAmount.setDrops(normalizedAmount.toString());
                    const payment = this.networkClient.Payment();
                    payment.setXrpAmount(xrpAmount);
                    payment.setDestination(destination);
                    const transaction = this.networkClient.Transaction();
                    transaction.setAccount(sender.getAddress());
                    transaction.setFee(fee);
                    transaction.setSequence(accountInfo.getSequence());
                    transaction.setPayment(payment);
                    transaction.setLastLedgerSequence(ledgerSequence + ledgerSequenceMargin);
                    transaction.setSigningPublicKeyHex(sender.getPublicKey());
                    let signedTransaction;
                    try {
                        signedTransaction = xpring_common_js_1.Signer.signLegacyTransaction(transaction, sender);
                    }
                    catch (signingError) {
                        const signingErrorMessage = `${LegacyXpringClientErrorMessages.signingFailure}. ${signingError.message}`;
                        return Promise.reject(new Error(signingErrorMessage));
                    }
                    if (signedTransaction === undefined) {
                        return Promise.reject(new Error(LegacyXpringClientErrorMessages.signingFailure));
                    }
                    const submitSignedTransactionRequest = this.networkClient.SubmitSignedTransactionRequest();
                    submitSignedTransactionRequest.setSignedTransaction(signedTransaction);
                    return this.networkClient
                        .submitSignedTransaction(submitSignedTransactionRequest)
                        .then(async (response) => {
                        const transactionBlob = response.getTransactionBlob();
                        const transactionHash = xpring_common_js_1.Utils.transactionBlobToTransactionHash(transactionBlob);
                        if (!transactionHash) {
                            return Promise.reject(new Error(LegacyXpringClientErrorMessages.malformedResponse));
                        }
                        return Promise.resolve(transactionHash);
                    });
                });
            });
        });
    }
    async getLastValidatedLedgerSequence() {
        const getLatestValidatedLedgerSequenceRequest = this.networkClient.GetLatestValidatedLedgerSequenceRequest();
        const ledgerSequence = await this.networkClient.getLatestValidatedLedgerSequence(getLatestValidatedLedgerSequenceRequest);
        return ledgerSequence.getIndex();
    }
    async getRawTransactionStatus(transactionHash) {
        const transactionStatusRequest = this.networkClient.GetTransactionStatusRequest();
        transactionStatusRequest.setTransactionHash(transactionHash);
        const transactionStatus = await this.networkClient.getTransactionStatus(transactionStatusRequest);
        return raw_transaction_status_1.default.fromTransactionStatus(transactionStatus);
    }
    async getAccountInfo(address) {
        const getAccountInfoRequest = this.networkClient.GetAccountInfoRequest();
        getAccountInfoRequest.setAddress(address);
        return this.networkClient.getAccountInfo(getAccountInfoRequest);
    }
    async getFee() {
        const getFeeRequest = this.networkClient.GetFeeRequest();
        return this.networkClient.getFee(getFeeRequest).then(async (fee) => {
            const feeAmount = fee.getAmount();
            if (feeAmount === undefined) {
                return Promise.reject(new Error(LegacyXpringClientErrorMessages.malformedResponse));
            }
            return feeAmount;
        });
    }
    async accountExists(address) {
        const classicAddress = xpring_common_js_1.Utils.decodeXAddress(address);
        if (!classicAddress) {
            throw new Error(LegacyXpringClientErrorMessages.xAddressRequired);
        }
        try {
            await this.getBalance(address);
            return true;
        }
        catch (e) {
            return false;
        }
    }
}
exports.default = LegacyDefaultXpringClient;
//# sourceMappingURL=legacy-default-xpring-client.js.map