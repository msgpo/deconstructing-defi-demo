"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const xpring_common_js_1 = require("xpring-common-js");
const big_integer_1 = __importDefault(require("big-integer"));
const transaction_status_1 = __importDefault(require("./transaction-status"));
const raw_transaction_status_1 = __importDefault(require("./raw-transaction-status"));
const grpc_network_client_1 = __importDefault(require("./grpc-network-client"));
const grpc_network_client_web_1 = __importDefault(require("./grpc-network-client.web"));
const account_pb_1 = require("./generated/web/org/xrpl/rpc/v1/account_pb");
const amount_pb_1 = require("./generated/web/org/xrpl/rpc/v1/amount_pb");
const utils_1 = __importDefault(require("./utils"));
const common_pb_1 = require("./generated/node/org/xrpl/rpc/v1/common_pb");
const transaction_pb_1 = require("./generated/web/org/xrpl/rpc/v1/transaction_pb");
/** A margin to pad the current ledger sequence with when submitting transactions. */
const maxLedgerVersionOffset = 10;
/**
 * Error messages from XpringClient.
 */
class XpringClientErrorMessages {
}
exports.XpringClientErrorMessages = XpringClientErrorMessages;
XpringClientErrorMessages.malformedResponse = 'Malformed Response.';
XpringClientErrorMessages.signingFailure = 'Unable to sign the transaction';
XpringClientErrorMessages.unimplemented = 'Unimplemented.';
/* eslint-disable @typescript-eslint/indent */
XpringClientErrorMessages.xAddressRequired = 'Please use the X-Address format. See: https://xrpaddress.info/.';
/**
 * DefaultXpringClient is a client which interacts with the Xpring platform.
 */
class DefaultXpringClient {
    /**
     * Create a new DefaultXpringClient with a custom network client implementation.
     *
     * In general, clients should prefer to call `xpringClientWithEndpoint`. This constructor is provided to improve testability of this class.
     *
     * @param networkClient A network client which will manage remote RPCs to Rippled.
     */
    constructor(networkClient) {
        this.networkClient = networkClient;
    }
    /**
     * Create a new DefaultXpringClient.
     *
     * The DefaultXpringClient will use gRPC to communicate with the given endpoint.
     *
     * @param grpcURL The URL of the gRPC instance to connect to.
     * @param forceWeb If `true`, then we will use the gRPC-Web client even when on Node. Defaults to false. This is mainly for testing and in the future will be removed when we have browser testing.
     */
    static defaultXpringClientWithEndpoint(grpcURL, forceWeb = false) {
        return utils_1.default() && !forceWeb
            ? new DefaultXpringClient(new grpc_network_client_1.default(grpcURL))
            : new DefaultXpringClient(new grpc_network_client_web_1.default(grpcURL));
    }
    /**
     * Retrieve the balance for the given address.
     *
     * @param address The X-Address to retrieve a balance for.
     * @returns A `BigInteger` representing the number of drops of XRP in the account.
     */
    async getBalance(address) {
        var _a, _b, _c;
        const classicAddress = xpring_common_js_1.Utils.decodeXAddress(address);
        if (!classicAddress) {
            return Promise.reject(new Error(XpringClientErrorMessages.xAddressRequired));
        }
        const account = this.networkClient.AccountAddress();
        account.setAddress(classicAddress.address);
        const request = this.networkClient.GetAccountInfoRequest();
        request.setAccount(account);
        const accountInfo = await this.networkClient.getAccountInfo(request);
        const accountData = accountInfo.getAccountData();
        if (!accountData) {
            throw new Error(XpringClientErrorMessages.malformedResponse);
        }
        const balance = (_c = (_b = (_a = accountData
            .getBalance()) === null || _a === void 0 ? void 0 : _a.getValue()) === null || _b === void 0 ? void 0 : _b.getXrpAmount()) === null || _c === void 0 ? void 0 : _c.getDrops();
        if (!balance) {
            throw new Error(XpringClientErrorMessages.malformedResponse);
        }
        return big_integer_1.default(balance);
    }
    /**
     * Retrieve the transaction status for a given transaction hash.
     *
     * @param transactionHash The hash of the transaction.
     * @returns The status of the given transaction.
     */
    async getTransactionStatus(transactionHash) {
        const transactionStatus = await this.getRawTransactionStatus(transactionHash);
        // Return pending if the transaction is not validated.
        if (!transactionStatus.isValidated) {
            return transaction_status_1.default.Pending;
        }
        return transactionStatus.transactionStatusCode.startsWith('tes')
            ? transaction_status_1.default.Succeeded
            : transaction_status_1.default.Failed;
    }
    /**
     * Send the given amount of XRP from the source wallet to the destination address.
     *
     * @param drops A `BigInteger`, number or numeric string representing the number of drops to send.
     * @param destinationAddress A destination address to send the drops to.
     * @param sender The wallet that XRP will be sent from and which will sign the request.
     * @returns A promise which resolves to a string representing the hash of the submitted transaction.
     */
    async send(drops, destinationAddress, sender) {
        if (!xpring_common_js_1.Utils.isValidXAddress(destinationAddress)) {
            throw new Error(XpringClientErrorMessages.xAddressRequired);
        }
        const classicAddress = xpring_common_js_1.Utils.decodeXAddress(sender.getAddress());
        if (!classicAddress) {
            throw new Error(XpringClientErrorMessages.xAddressRequired);
        }
        const normalizedDrops = drops.toString();
        const fee = await this.getMinimumFee();
        const accountData = await this.getAccountData(classicAddress.address);
        const lastValidatedLedgerSequence = await this.getLastValidatedLedgerSequence();
        const xrpDropsAmount = new amount_pb_1.XRPDropsAmount();
        xrpDropsAmount.setDrops(normalizedDrops);
        const currencyAmount = new amount_pb_1.CurrencyAmount();
        currencyAmount.setXrpAmount(xrpDropsAmount);
        const amount = new common_pb_1.Amount();
        amount.setValue(currencyAmount);
        const destinationAccountAddress = new account_pb_1.AccountAddress();
        destinationAccountAddress.setAddress(destinationAddress);
        const destination = new common_pb_1.Destination();
        destination.setValue(destinationAccountAddress);
        const senderAccountAddress = new account_pb_1.AccountAddress();
        senderAccountAddress.setAddress(sender.getAddress());
        const account = new common_pb_1.Account();
        account.setValue(senderAccountAddress);
        const payment = new transaction_pb_1.Payment();
        payment.setDestination(destination);
        payment.setAmount(amount);
        const lastLedgerSequence = new common_pb_1.LastLedgerSequence();
        lastLedgerSequence.setValue(lastValidatedLedgerSequence + maxLedgerVersionOffset);
        const signingPublicKeyBytes = xpring_common_js_1.Utils.toBytes(sender.getPublicKey());
        const signingPublicKey = new common_pb_1.SigningPublicKey();
        signingPublicKey.setValue(signingPublicKeyBytes);
        const transaction = new transaction_pb_1.Transaction();
        transaction.setAccount(account);
        transaction.setFee(fee);
        transaction.setSequence(accountData.getSequence());
        transaction.setPayment(payment);
        transaction.setLastLedgerSequence(lastLedgerSequence);
        transaction.setSigningPublicKey(signingPublicKey);
        const signedTransaction = xpring_common_js_1.Signer.signTransaction(transaction, sender);
        if (!signedTransaction) {
            throw new Error(XpringClientErrorMessages.malformedResponse);
        }
        const submitTransactionRequest = this.networkClient.SubmitTransactionRequest();
        submitTransactionRequest.setSignedTransaction(signedTransaction);
        const response = await this.networkClient.submitTransaction(submitTransactionRequest);
        return xpring_common_js_1.Utils.toHex(response.getHash_asU8());
    }
    async getLastValidatedLedgerSequence() {
        const getFeeResponse = await this.getFee();
        return getFeeResponse.getLedgerCurrentIndex();
    }
    async getRawTransactionStatus(transactionHash) {
        const getTxRequest = this.networkClient.GetTransactionRequest();
        getTxRequest.setHash(xpring_common_js_1.Utils.toBytes(transactionHash));
        const getTxResponse = await this.networkClient.getTransaction(getTxRequest);
        return raw_transaction_status_1.default.fromGetTransactionResponse(getTxResponse);
    }
    async getMinimumFee() {
        var _a;
        const getFeeResponse = await this.getFee();
        const fee = (_a = getFeeResponse.getFee()) === null || _a === void 0 ? void 0 : _a.getMinimumFee();
        if (!fee) {
            throw new Error(XpringClientErrorMessages.malformedResponse);
        }
        return fee;
    }
    async getFee() {
        const getFeeRequest = this.networkClient.GetFeeRequest();
        return this.networkClient.getFee(getFeeRequest);
    }
    async getAccountData(address) {
        const account = this.networkClient.AccountAddress();
        account.setAddress(address);
        const request = this.networkClient.GetAccountInfoRequest();
        request.setAccount(account);
        const accountInfo = await this.networkClient.getAccountInfo(request);
        if (!accountInfo) {
            throw new Error(XpringClientErrorMessages.malformedResponse);
        }
        const accountData = accountInfo.getAccountData();
        if (!accountData) {
            throw new Error(XpringClientErrorMessages.malformedResponse);
        }
        return accountData;
    }
    /**
     * Check if an address exists on the XRP Ledger.
     *
     * @param address The address to check the existence of.
     * @returns A boolean if the account is on the ledger.
     */
    async accountExists(address) {
        const classicAddress = xpring_common_js_1.Utils.decodeXAddress(address);
        if (!classicAddress) {
            throw new Error(XpringClientErrorMessages.xAddressRequired);
        }
        try {
            await this.getBalance(address);
            return true;
        }
        catch (e) {
            return false;
        }
    }
}
exports.default = DefaultXpringClient;
//# sourceMappingURL=default-xpring-client.js.map