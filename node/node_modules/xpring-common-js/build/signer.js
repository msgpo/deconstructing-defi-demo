"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const rippleCodec = __importStar(require("ripple-binary-codec"));
const serializer_1 = __importDefault(require("./serializer"));
const signed_transaction_pb_1 = require("./generated/legacy/signed_transaction_pb");
const utils_1 = __importDefault(require("./utils"));
/**
 * Abstracts the details of signing.
 */
class Signer {
    /**
     * Encode the given object to hex and sign it.
     *
     * @param transaction The transaction to sign.
     * @param wallet The wallet to sign the transaction with.
     * @returns A set of bytes representing the inputs and a signature.
     */
    static signTransaction(transaction, wallet) {
        if (transaction === undefined || wallet === undefined) {
            return undefined;
        }
        const transactionJSON = serializer_1.default.transactionToJSON(transaction);
        if (transactionJSON === undefined) {
            return undefined;
        }
        const transactionHex = rippleCodec.encodeForSigning(transactionJSON);
        const signatureHex = wallet.sign(transactionHex);
        if (!signatureHex) {
            throw new Error('Unable to produce a signature.');
        }
        const signedTransactionJSON = serializer_1.default.transactionToJSON(transaction, signatureHex);
        const signedTransactionHex = rippleCodec.encode(signedTransactionJSON);
        return utils_1.default.toBytes(signedTransactionHex);
    }
    /**
     * Encode the given object to hex and sign it.
     *
     * @param {Transaction} transaction The transaction to sign.
     * @param {Wallet} wallet The wallet to sign the transaction with.
     * @returns {SignedTransaction} A signed transaction.
     */
    static signLegacyTransaction(transaction, wallet) {
        if (transaction === undefined || wallet === undefined) {
            return undefined;
        }
        const transactionJSON = serializer_1.default.legacyTransactionToJSON(transaction);
        if (transactionJSON === undefined) {
            return undefined;
        }
        const transactionHex = rippleCodec.encodeForSigning(transactionJSON);
        const signatureHex = wallet.sign(transactionHex);
        if (signatureHex === undefined) {
            return undefined;
        }
        const signedTransaction = new signed_transaction_pb_1.SignedTransaction();
        signedTransaction.setTransaction(transaction);
        signedTransaction.setTransactionSignatureHex(signatureHex);
        return signedTransaction;
    }
}
exports.default = Signer;
//# sourceMappingURL=signer.js.map