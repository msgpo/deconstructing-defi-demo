"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
const addressCodec = __importStar(require("ripple-address-codec"));
/**
 * A prefex applied when hashing a signed transaction blob.
 *
 * @see https://xrpl.org/basic-data-types.html#hashes
 */
const signedTransactionPrefixHex = '54584E00';
class Utils {
    /**
     * Validate that the given string is a valid address for the XRP Ledger.
     *
     * This function returns true for both X-addresses and classic addresses.
     * @see https://xrpaddress.info/
     *
     * @param address An address to check.
     * @returns True if the address is valid, otherwise false.
     */
    static isValidAddress(address) {
        return (addressCodec.isValidClassicAddress(address) ||
            addressCodec.isValidXAddress(address));
    }
    /**
     * Validate whether the given string is a valid X-address for the XRP Ledger.
     *
     * @see https://xrpaddress.info/
     *
     * @param address An address to check.
     * @returns True if the address is a valid X-address, otherwise false.
     */
    static isValidXAddress(address) {
        return addressCodec.isValidXAddress(address);
    }
    /**
     * Validate whether the given string is a valid classic address for the XRP Ledger.
     *
     * @see https://xrpaddress.info/
     *
     * @param address An address to check.
     * @returns True if the address is a valid classic address, otherwise false.
     */
    static isValidClassicAddress(address) {
        return addressCodec.isValidClassicAddress(address);
    }
    /**
     * Encode the given classic address and tag into an x-address.
     *
     * @see https://xrpaddress.info/
     *
     * @param classicAddress A classic address to encode.
     * @param tag An optional tag to encode.
     * @param test Whether the address is for use on a test network, defaults to `false`.
     * @returns A new x-address if inputs were valid, otherwise undefined.
     */
    static encodeXAddress(classicAddress, tag, test = false) {
        if (!addressCodec.isValidClassicAddress(classicAddress)) {
            return undefined;
        }
        // Xpring Common JS's API takes a string|undefined while the underlying address library wants string|false.
        const shimTagParameter = tag !== undefined ? tag : false;
        return addressCodec.classicAddressToXAddress(classicAddress, shimTagParameter, test);
    }
    /**
     * Decode a `ClassicAddress` from a given x-address.
     *
     * @see https://xrpaddress.info/
     *
     * @param xAddress The xAddress to decode.
     * @returns A `ClassicAddress`
     */
    static decodeXAddress(xAddress) {
        if (!addressCodec.isValidXAddress(xAddress)) {
            return undefined;
        }
        const shimClassicAddress = addressCodec.xAddressToClassicAddress(xAddress);
        return {
            address: shimClassicAddress.classicAddress,
            tag: shimClassicAddress.tag !== false ? shimClassicAddress.tag : undefined,
            test: shimClassicAddress.test,
        };
    }
    /**
     * Convert the given byte array to a hexadecimal string.
     *
     * @param bytes An array of bytes
     * @returns An encoded hexadecimal string.
     */
    static toHex(bytes) {
        return Buffer.from(bytes)
            .toString('hex')
            .toUpperCase();
    }
    /**
     * Convert the given hexadecimal string to a byte array.
     *
     * @param hex A hexadecimal string.
     * @returns A decoded byte array.
     */
    static toBytes(hex) {
        return Uint8Array.from(Buffer.from(hex, 'hex'));
    }
    /**
     * Convert the given transaction blob to a transaction hash.
     *
     * @param transactionBlobHex A hexadecimal encoded transaction blob.
     * @returns A hex encoded hash if the input was valid, otherwise undefined.
     */
    static transactionBlobToTransactionHash(transactionBlobHex) {
        if (!Utils.isHex(transactionBlobHex)) {
            return undefined;
        }
        const prefixedTransactionBlob = this.toBytes(signedTransactionPrefixHex + transactionBlobHex);
        const hash = this.sha512Half(prefixedTransactionBlob);
        return this.toHex(hash);
    }
    /**
     * Compute the SHA512 half hash of the given bytes.
     *
     * @param input The input to hash.
     * @returns The hash of the input.
     */
    static sha512Half(bytes) {
        const sha512 = crypto_1.createHash('sha512');
        const hashHex = sha512
            .update(bytes)
            .digest('hex')
            .toUpperCase();
        const hash = this.toBytes(hashHex);
        return hash.slice(0, 32);
    }
    /**
     * Check if the given string is valid hex.
     *
     * @param input The input to check.
     * @returns true if the input is valid hex, otherwise false.
     */
    static isHex(input) {
        const hexRegEx = /([0-9]|[a-f])/gim;
        return (input.match(hexRegEx) || []).length === input.length;
    }
}
exports.default = Utils;
//# sourceMappingURL=utils.js.map