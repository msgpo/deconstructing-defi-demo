"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const bip32 = __importStar(require("bip32"));
const bip39 = __importStar(require("bip39"));
const rippleKeyPair = __importStar(require("ripple-keypairs"));
const utils_1 = __importDefault(require("./utils"));
/**
 * The default derivation path to use with BIP44.
 */
const defaultDerivationPath = "m/44'/144'/0'/0/0";
/**
 * A wallet object that has an address and keypair.
 */
class Wallet {
    /**
     * Create a new Wallet object.
     *
     * @param publicKey The given public key for the wallet.
     * @param privateKey The given private key for the wallet.
     * @param test Whether the address is for use on a test network, defaults to `false`.
     */
    constructor(publicKey, privateKey, test = false) {
        this.publicKey = publicKey;
        this.privateKey = privateKey;
        this.test = test;
    }
    /**
     * @returns {String} The default derivation path.
     */
    static getDefaultDerivationPath() {
        return defaultDerivationPath;
    }
    /**
     * Generate a new wallet hierarchical deterministic wallet with a random mnemonic and
     * default derivation path.
     *
     * Secure random number generation is used when entropy is ommitted and when the runtime environment has the necessary support. Otherwise, an error is thrown. Runtime environments that do not have secure random number generation should pass their own buffer of entropy.
     *
     * @param entropy A optional hex string of entropy.
     * @param test Whether the address is for use on a test network, defaults to `false`.
     * @returns Artifacts from the wallet generation.
     */
    static generateRandomWallet(entropy = undefined, test = false) {
        if (entropy && !utils_1.default.isHex(entropy)) {
            return undefined;
        }
        const mnemonic = entropy === undefined
            ? bip39.generateMnemonic()
            : bip39.entropyToMnemonic(entropy);
        const derivationPath = Wallet.getDefaultDerivationPath();
        const wallet = Wallet.generateWalletFromMnemonic(mnemonic, derivationPath, test);
        return wallet === undefined
            ? undefined
            : { wallet, mnemonic, derivationPath };
    }
    /**
     * Generate a new hierarchical deterministic wallet from a mnemonic and derivation path.
     *
     * @param mnemonic The given mnemonic for the wallet.
     * @param derivationPath The given derivation path to use. If undefined, the default path is used.
     * @param test Whether the address is for use on a test network, defaults to `false`.
     * @returns A new wallet from the given mnemonic if the mnemonic was valid, otherwise undefined.
     */
    static generateWalletFromMnemonic(mnemonic, derivationPath = Wallet.getDefaultDerivationPath(), test = false) {
        // Validate mnemonic and path are valid.
        if (!bip39.validateMnemonic(mnemonic)) {
            return undefined;
        }
        const seed = bip39.mnemonicToSeedSync(mnemonic);
        return Wallet.generateHDWalletFromSeed(seed, derivationPath, test);
    }
    /**
     * Generate a new hierarchical deterministic wallet from a seed and derivation path.
     *
     * @param seed The given seed for the wallet.
     * @param derivationPath The given derivation path to use. If undefined, the default path is used.
     * @param test Whether the address is for use on a test network, defaults to `false`.
     * @returns A new wallet from the given mnemonic if the mnemonic was valid, otherwise undefined.
     */
    static generateHDWalletFromSeed(seed, derivationPath = Wallet.getDefaultDerivationPath(), test = false) {
        const masterNode = bip32.fromSeed(seed);
        const node = masterNode.derivePath(derivationPath);
        if (node.privateKey === undefined)
            return;
        const publicKey = Wallet.hexFromBuffer(node.publicKey);
        const privateKey = Wallet.hexFromBuffer(node.privateKey);
        return new Wallet(publicKey, `00${privateKey}`, test);
    }
    /**
     * Generate a new wallet from the given seed.
     *
     * @param seed The given seed for the wallet.
     * @param test Whether the address is for use on a test network, defaults to `false`.
     * @returns A new wallet from the given seed, or undefined if the seed was invalid.
     */
    static generateWalletFromSeed(seed, test = false) {
        try {
            const keyPair = rippleKeyPair.deriveKeypair(seed);
            return new Wallet(keyPair.publicKey, keyPair.privateKey, test);
        }
        catch (exception) {
            return undefined;
        }
    }
    /**
     * @returns {String} A string representing the public key for the wallet.
     */
    getPublicKey() {
        return this.publicKey;
    }
    /**
     * @returns {String} A string representing the private key for the wallet.
     */
    getPrivateKey() {
        return this.privateKey;
    }
    /**
     * @returns {String} A string representing the address of the wallet.
     */
    getAddress() {
        const classicAddress = rippleKeyPair.deriveAddress(this.getPublicKey());
        const xAddress = utils_1.default.encodeXAddress(classicAddress, undefined, this.test);
        if (xAddress === undefined) {
            throw new Error('Unknown error deriving address');
        }
        return xAddress;
    }
    /**
     * Sign an arbitrary hex string.
     *
     * @param {String} hex An arbitrary hex string to sign.
     * @returns {String} A signature in hexadecimal format if the input was valid, otherwise undefined.
     */
    sign(hex) {
        if (!utils_1.default.isHex(hex)) {
            return undefined;
        }
        return rippleKeyPair.sign(hex, this.getPrivateKey());
    }
    /**
     * Verify a signature is valid for a message.
     *
     * @param {String} message A message in hex format.
     * @param {String} signature A signature in hex format.
     * @returns {Boolean} True if the signature is valid, otherwise false.
     */
    verify(message, signature) {
        if (!utils_1.default.isHex(signature) || !utils_1.default.isHex(message)) {
            return false;
        }
        try {
            return rippleKeyPair.verify(message, signature, this.getPublicKey());
        }
        catch (error) {
            // The ripple-key-pair module may throw errors for some signatures rather than returning false.
            // If an error was thrown then the signature is definitely not valid.
            return false;
        }
    }
    static hexFromBuffer(buffer) {
        return buffer.toString('hex').toUpperCase();
    }
}
exports.default = Wallet;
//# sourceMappingURL=wallet.js.map