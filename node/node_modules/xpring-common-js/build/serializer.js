"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const payment_pb_1 = require("./generated/legacy/payment_pb");
const transaction_pb_1 = require("./generated/org/xrpl/rpc/v1/transaction_pb");
const utils_1 = __importDefault(require("./utils"));
/**
 * Provides functionality to serialize from protocol buffers to JSON objects.
 */
class Serializer {
    /**
     * Convert a Transaction to a JSON representation.
     *
     * @param {proto.Transaction} transaction A Transaction to convert.
     * @param signature An optional hex encoded signature to include in the transaction.
     * @returns {Object} The Transaction as JSON.
     */
    static transactionToJSON(transaction, signature) {
        var _a, _b, _c, _d;
        const object = {
            Account: '',
            Sequence: 0,
            SigningPubKey: '',
            LastLedgerSequence: 0,
            Fee: '',
        };
        const sequence = (_a = transaction.getSequence()) === null || _a === void 0 ? void 0 : _a.getValue();
        if (sequence) {
            object.Sequence = sequence;
        }
        const signingPubKeyBytes = (_b = transaction
            .getSigningPublicKey()) === null || _b === void 0 ? void 0 : _b.getValue_asU8();
        if (signingPubKeyBytes) {
            object.SigningPubKey = utils_1.default.toHex(signingPubKeyBytes);
        }
        const lastLedgerSequence = (_c = transaction.getLastLedgerSequence()) === null || _c === void 0 ? void 0 : _c.getValue();
        if (lastLedgerSequence) {
            object.LastLedgerSequence = lastLedgerSequence;
        }
        // Convert account field, handling X-Addresses if needed.
        const accountAddress = transaction.getAccount();
        if (!accountAddress) {
            return;
        }
        const account = (_d = accountAddress.getValue()) === null || _d === void 0 ? void 0 : _d.getAddress();
        if (!account || !utils_1.default.isValidAddress(account)) {
            return;
        }
        let normalizedAccount = account;
        if (utils_1.default.isValidXAddress(account)) {
            const decodedClassicAddress = utils_1.default.decodeXAddress(account);
            if (!decodedClassicAddress) {
                return;
            }
            // Accounts cannot have a tag.
            if (decodedClassicAddress.tag !== undefined) {
                return;
            }
            normalizedAccount = decodedClassicAddress.address;
        }
        object.Account = normalizedAccount;
        // Convert XRP denominated fee field.
        const txFee = transaction.getFee();
        if (txFee === undefined) {
            return;
        }
        object.Fee = this.xrpAmountToJSON(txFee);
        // Convert additional transaction data.
        const transactionDataCase = transaction.getTransactionDataCase();
        switch (transactionDataCase) {
            case transaction_pb_1.Transaction.TransactionDataCase.PAYMENT: {
                const payment = transaction.getPayment();
                if (payment === undefined) {
                    return;
                }
                Object.assign(object, this.paymentToJSON(payment));
                break;
            }
            default:
                throw new Error('Unexpected transactionDataCase');
        }
        if (signature) {
            object.TxnSignature = signature;
        }
        return object;
    }
    /**
     * Convert a Payment to a JSON representation.
     *
     * @param {proto.Payment} payment The Payment to convert.
     * @returns {Object} The Payment as JSON.
     */
    static paymentToJSON(payment) {
        var _a, _b;
        const json = {
            Amount: {},
            Destination: '',
            TransactionType: 'Payment',
        };
        // If an x-address was able to be decoded, add the components to the json.
        const destinationAddress = payment.getDestination();
        if (!destinationAddress) {
            return;
        }
        const destination = (_a = destinationAddress.getValue()) === null || _a === void 0 ? void 0 : _a.getAddress();
        if (!destination) {
            return;
        }
        const decodedXAddress = utils_1.default.decodeXAddress(destination);
        if (!decodedXAddress) {
            json.Destination = destination;
            delete json.DestinationTag;
        }
        else {
            json.Destination = decodedXAddress.address;
            if (decodedXAddress.tag !== undefined) {
                json.DestinationTag = decodedXAddress.tag;
            }
        }
        const amount = payment.getAmount();
        if (!amount) {
            return;
        }
        const xrpAmount = (_b = amount.getValue()) === null || _b === void 0 ? void 0 : _b.getXrpAmount();
        if (!xrpAmount) {
            return;
        }
        json.Amount = this.xrpAmountToJSON(xrpAmount);
        return json;
    }
    /**
     * Convert an XRPDropsAmount to a JSON representation.
     *
     * @param xrpDropsAmount The XRPAmount to convert.
     * @returns The XRPAmount as JSON.
     */
    static xrpAmountToJSON(xrpDropsAmount) {
        return `${xrpDropsAmount.getDrops()}`;
    }
    /**
     * Convert a Transaction to a JSON representation.
     *
     * @param {proto.Transaction} transaction A Transaction to convert.
     * @returns {Object} The Transaction as JSON.
     */
    static legacyTransactionToJSON(transaction) {
        const object = {
            Account: '',
            Sequence: 0,
            SigningPubKey: '',
            LastLedgerSequence: 0,
            Fee: '',
        };
        object.Sequence = transaction.getSequence();
        object.SigningPubKey = transaction.getSigningPublicKeyHex();
        object.LastLedgerSequence = transaction.getLastLedgerSequence();
        // Convert account field, handling X-Addresses if needed.
        const account = transaction.getAccount();
        if (!account || !utils_1.default.isValidAddress(account)) {
            return;
        }
        let normalizedAccount = account;
        if (utils_1.default.isValidXAddress(account)) {
            const decodedClassicAddress = utils_1.default.decodeXAddress(account);
            if (!decodedClassicAddress) {
                return;
            }
            // Accounts cannot have a tag.
            if (decodedClassicAddress.tag !== undefined) {
                return;
            }
            normalizedAccount = decodedClassicAddress.address;
        }
        object.Account = normalizedAccount;
        // Convert XRP denominated fee field.
        const txFee = transaction.getFee();
        if (txFee === undefined) {
            return;
        }
        object.Fee = this.legacyXRPAmountToJSON(txFee);
        // Convert additional transaction data.
        const transactionDataCase = transaction.getTransactionDataCase();
        switch (transactionDataCase) {
            case transaction_pb_1.Transaction.TransactionDataCase.PAYMENT: {
                const payment = transaction.getPayment();
                if (payment === undefined) {
                    return;
                }
                Object.assign(object, this.legacyPaymentToJSON(payment));
                break;
            }
            default:
                throw new Error('Unexpected transactionDataCase');
        }
        return object;
    }
    /**
     * Convert a Payment to a JSON representation.
     *
     * @param payment The Payment to convert.
     * @returns The Payment as JSON.
     */
    static legacyPaymentToJSON(payment) {
        const json = {
            Amount: {},
            Destination: '',
            TransactionType: 'Payment',
        };
        // If an x-address was able to be decoded, add the components to the json.
        const decodedXAddress = utils_1.default.decodeXAddress(payment.getDestination());
        if (!decodedXAddress) {
            json.Destination = payment.getDestination();
            delete json.DestinationTag;
        }
        else {
            json.Destination = decodedXAddress.address;
            if (decodedXAddress.tag !== undefined) {
                json.DestinationTag = decodedXAddress.tag;
            }
        }
        const amountCase = payment.getAmountCase();
        switch (amountCase) {
            case payment_pb_1.Payment.AmountCase.FIAT_AMOUNT: {
                return;
            }
            case payment_pb_1.Payment.AmountCase.XRP_AMOUNT: {
                const xrpAmount = payment.getXrpAmount();
                if (xrpAmount === undefined) {
                    return;
                }
                json.Amount = this.legacyXRPAmountToJSON(xrpAmount);
                break;
            }
            default:
                throw new Error('Unexpected amountCase');
        }
        return json;
    }
    /**
     * Convert an XRPAmount to a JSON representation.
     *
     * @param {proto.XRPAmount} xrpAmount The XRPAmount to convert.
     * @return {String} The XRPAmount as JSON.
     */
    static legacyXRPAmountToJSON(xrpAmount) {
        return `${xrpAmount.getDrops()}`;
    }
}
exports.default = Serializer;
//# sourceMappingURL=serializer.js.map